# `unix-sort` - UNIX-утилита `sort` на Go с поддержкой внешней сортировки

Этот проект представляет собой **полную реализацию** утилиты `sort`, совместимую с GNU coreutils. Программа корректно обрабатывает как небольшие, так и **гигантские файлы**, используя **внешнюю сортировку с многоуровневым K-путевым слиянием**, когда данные не помещаются в заданный лимит памяти.

Реализация поддерживает все обязательные и дополнительные флаги GNU `sort` и полностью совместима с `gsort`.

---
### Ключевые возможности

- **Автоматическое переключение между in-memory и внешней сортировкой** при превышении лимита памяти (по умолчанию - 100 МБ)
- **Многоуровневое внешнее слияние**: эффективная обработка миллионов строк и терабайтов данных
- **Стабильная сортировка**: сохраняется исходный порядок при равенстве ключей
- Чтение из файла или `stdin`, вывод в `stdout`
- Полная совместимость с `gsort` (GNU sort)

---

### Поддерживаемые флаги

### Обязательные:
- `-k N` - сортировка по N-й колонке (разделённой **табуляцией**, нумерация с 1)
- `-n` - числовая сортировка (поддержка дробных и отрицательных чисел)
- `-r` - обратный порядок
- `-u` - вывод только уникальных строк (первая из группы)
- `-b` - игнорировать ведущие и завершающие пробелы/табуляции

### Дополнительные:
- `-M` - сортировка по названию месяца (`Jan`, `Feb`, ..., `Dec`)
- `-h` - сортировка человекочитаемых размеров (`1K`, `2M`, `1.5Gi`, и т.д.)
- `-c` - проверка, отсортирован ли вход; при нарушении — ошибка и выход с кодом 1

---

### In-memory сортировка
- Используется при объёме входных данных **≤ 100 МБ**
- `sort.SliceStable` с кастомным компаратором
- Поддержка всех флагов в единой логике сравнения

### Внешняя сортировка
Когда данные превышают лимит:
1. **Разбиение**: вход читается потоково и разбивается на **отсортированные порции**, каждая из которых помещается в память.
2. **Сброс**: каждая порция записывается во временный файл.
3. **K-путевое слияние**: файлы сливаются с использованием **min heap**.
4. **Многоуровневость**: если число временных файлов превышает лимит открытых дескрипторов (`maxOpenFiles = 64`), выполняется **рекурсивное слияние** на промежуточные файлы.
5. **Очистка**: все временные файлы удаляются даже при аварийном завершении (`defer cleanup`).

Вся логика чтения реализована через **единый `bufio.Scanner`**, что исключает потерю или дублирование данных.

---

### Тестирование

Программа проходит:

- **Полное сравнение с `gsort`** на файлах до 1 млн строк
- Тесты edge case'ов:
    - пустой файл, одна строка
    - файл без завершающего `\n`
    - пустые строки, дубликаты
    - длинные строки (до лимита `bufio.Scanner`)
    - все комбинации флагов (`-n -r -k 2 -b -u -h -M -c`)
- Проверка **внешней сортировки** при искусственно сниженном лимите памяти (100 байт)
- Работа со `stdin` и большими файлами
- `golangci-lint` без предупреждений

---

### Использование

```bash
# Сортировка файла
go run . data.txt

# Сортировка stdin
cat data.txt | go run .

# Числовая сортировка по 2-й колонке с уникальностью
go run . -k 2 -n -u data.txt

# Проверка отсортированности
go run . -c data.txt
```
---
### Архитектура

- `main.go` — парсинг флагов, управление памятью, выбор режима сортировки
- `sortutil/sortutil.go` — in-memory сортировка, сравнение ключей, уникальность
- `sortutil/external.go` — внешняя сортировка, многоуровневое слияние, работа с временными файлами
ф